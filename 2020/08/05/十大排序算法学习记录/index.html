<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法," />










<meta name="description" content="最近在重学算法，说到算法肯定绕不开排序算法，因此特地写了这篇博客总结自己学习十大排序算法的过程，也方便以后自己重温时不要再反复百度吧。 ¶前言 ¶1.术语说明   稳定 ：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面； 不稳定 ：如果a原本在b的前面，而a&#x3D;b，排序之后a可能会出现在b的后面； 内排序 ：所有排序操作都在内存中完成； 外排序 ：由于数据太大，因此把数据放在">
<meta property="og:type" content="article">
<meta property="og:title" content="十大排序算法学习记录">
<meta property="og:url" content="http://yoursite.com/2020/08/05/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="Hong YueTang&#96;s Blog">
<meta property="og:description" content="最近在重学算法，说到算法肯定绕不开排序算法，因此特地写了这篇博客总结自己学习十大排序算法的过程，也方便以后自己重温时不要再反复百度吧。 ¶前言 ¶1.术语说明   稳定 ：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面； 不稳定 ：如果a原本在b的前面，而a&#x3D;b，排序之后a可能会出现在b的后面； 内排序 ：所有排序操作都在内存中完成； 外排序 ：由于数据太大，因此把数据放在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tomush-blog.oss-cn-shenzhen.aliyuncs.com/tomush-blog/imgs/1.jfif">
<meta property="og:image" content="https://tomush-blog.oss-cn-shenzhen.aliyuncs.com/tomush-blog/imgs/2.jfif">
<meta property="og:image" content="https://tomush-blog.oss-cn-shenzhen.aliyuncs.com/tomush-blog/imgs/3.jfif">
<meta property="article:published_time" content="2020-08-05T11:12:48.000Z">
<meta property="article:modified_time" content="2020-08-05T13:43:03.015Z">
<meta property="article:author" content="Hong YueTang">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tomush-blog.oss-cn-shenzhen.aliyuncs.com/tomush-blog/imgs/1.jfif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/08/05/十大排序算法学习记录/"/>





  <title>十大排序算法学习记录 | Hong YueTang`s Blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hong YueTang`s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/05/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hong YueTang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hong YueTang`s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">十大排序算法学习记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-05T19:12:48+08:00">
                2020-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>        最近在重学算法，说到算法肯定绕不开排序算法，因此特地写了这篇博客总结自己学习十大排序算法的过程，也方便以后自己重温时不要再反复百度吧。</p>
<h3 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h3>
<h5 id="1-术语说明"><a class="header-anchor" href="#1-术语说明">¶</a>1.术语说明</h5>
<blockquote>
<ul>
<li>稳定 ：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li>
<li>不稳定 ：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li>
<li>内排序 ：所有排序操作都在内存中完成；</li>
<li>外排序 ：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li>原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。</li>
<li>非原地排序：需要利用额外的数组来辅助排序。</li>
<li>时间复杂度 ： 一个算法执行所耗费的时间。</li>
<li>空间复杂度 ：运行完一个程序所需内存的大小。</li>
</ul>
</blockquote>
<h5 id="2-算法总结"><a class="header-anchor" href="#2-算法总结">¶</a>2.算法总结</h5>
<p><img src="https://tomush-blog.oss-cn-shenzhen.aliyuncs.com/tomush-blog/imgs/1.jfif" alt="算法总结"></p>
<ul>
<li>名词解释说明</li>
</ul>
<blockquote>
<p>n: 数据规模<br>
k: “桶”的个数<br>
In-place: 占用常数内存，不占用额外内存<br>
Out-place: 占用额外内存</p>
</blockquote>
<h5 id="3-算法分类"><a class="header-anchor" href="#3-算法分类">¶</a>3.算法分类</h5>
<p><img src="https://tomush-blog.oss-cn-shenzhen.aliyuncs.com/tomush-blog/imgs/2.jfif" alt="算法分类"></p>
<h5 id="4-比较和非比较的区别"><a class="header-anchor" href="#4-比较和非比较的区别">¶</a>4.比较和非比较的区别</h5>
<blockquote>
<p>        常见的 <strong>快速排序</strong>、<strong>归并排序</strong>、<strong>堆排序</strong>、<strong>冒泡排序</strong> 等属于 <strong>比较排序</strong>。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置 。<br>
        在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。<br>
        比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。<br>
        <strong>计数排序</strong>、<strong>基数排序</strong>、<strong>桶排序</strong> 则属于 <strong>非比较排序</strong> 。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置 。<br>
        非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。<br>
         非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p>
</blockquote>
<h3 id="一、冒泡排序（Bubble-Sort）"><a class="header-anchor" href="#一、冒泡排序（Bubble-Sort）">¶</a>一、冒泡排序（Bubble Sort）</h3>
<p><strong>冒泡排序</strong> 是一种简单的排序算法。它重复地遍历要排序的数列，从第一位开始比较相邻的两个元素，如果它们的顺序错误就把它们交换过来，直到待排序的元素位于数列最右端，然后重复第二遍比较，直到排序好的元素前一位。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h5 id="1-算法描述"><a class="header-anchor" href="#1-算法描述">¶</a>1.算法描述</h5>
<blockquote>
<ul>
<li>步骤1：比较相邻的元素，如果第一个比第二个元素大，就交换他们的位置；</li>
<li>步骤2：对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>步骤3: 针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>步骤4: 重复步骤1~3，直到排序完成。</li>
</ul>
</blockquote>
<h5 id="2-代码实现"><a class="header-anchor" href="#2-代码实现">¶</a>2.代码实现</h5>
<pre><code>/**
 * 冒泡排序
 */
public static int[] bubbleSort(int[] array) {
    if (array.length == 0)
        return array;
 	//i=array.length-2时只剩下2两个元素未排序，走完这趟循环后数组已排序完毕
    for (int i = 0; i &lt; array.length-1; i++)
        for (int j = 0; j &lt; array.length - 1 - i; j++)
            if (array[j + 1] &lt; array[j]) {
                int temp = array[j + 1];
                array[j + 1] = array[j];
                array[j] = temp;
            }
    return array;
}
</code></pre>
<h3 id="二、选择排序（Selection-Sort）"><a class="header-anchor" href="#二、选择排序（Selection-Sort）">¶</a>二、选择排序（Selection Sort）</h3>
<p><strong>选择排序</strong> 是表现最稳定的排序算法之一 ，<strong>因为无论什么数据进去都是O(n2)的时间复杂度</strong> ，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。<br>
        <strong>选择排序(Selection-sort)</strong> 是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h5 id="1-算法描述-v2"><a class="header-anchor" href="#1-算法描述-v2">¶</a>1.算法描述</h5>
<blockquote>
<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li>步骤1：初始状态：无序区为R[1…n]，有序区为空；</li>
<li>步骤2：第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>步骤3：n-1趟结束，数组有序化了。</li>
</ul>
</blockquote>
<h5 id="2-代码实现-v2"><a class="header-anchor" href="#2-代码实现-v2">¶</a>2.代码实现</h5>
<pre><code> /**
 * 选择排序
 * @param array
 * @return
 */
public static int[] selectionSort(int[] array) {
    if (array.length == 0)
        return array;
    for (int i = 0; i &lt; array.length-1; i++) {
        int minIndex = i;
        for (int j = i+1; j &lt; array.length; j++) {
            if (array[j] &lt; array[minIndex]) //找到最小的数
                minIndex = j; //将最小数的索引保存
        }
        int temp = array[minIndex];
        array[minIndex] = array[i];
        array[i] = temp;
    }
    return array;
}
</code></pre>
<h3 id="三、插入排序（Insertion-Sort）"><a class="header-anchor" href="#三、插入排序（Insertion-Sort）">¶</a>三、插入排序（Insertion Sort）</h3>
<p><strong>插入排序（Insertion-Sort）</strong> 的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h5 id="1-算法描述-v3"><a class="header-anchor" href="#1-算法描述-v3">¶</a>1.算法描述</h5>
<blockquote>
<p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li>步骤1: 从第一个元素开始，该元素可以认为已经被排序；</li>
<li>步骤2: 取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>步骤3: 如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>步骤4: 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>步骤5: 将新元素插入到该位置后；</li>
<li>步骤6: 重复步骤2~5。</li>
</ul>
</blockquote>
<h5 id="2-代码实现-v3"><a class="header-anchor" href="#2-代码实现-v3">¶</a>2.代码实现</h5>
<pre><code>  public static int[] insertionSort(int[] array) {
    if (array.length == 0)
        return array;
    int current,preIndex;
    //第一个元素默认已排序，所以从下标为1开始排序
    for (int i = 1; i &lt; array.length; i++) {
    	current = array[i];  //获取当前要排序的元素
    	preIndex = i-1;	 	 //进入有序区
    	while (preIndex &gt;= 0 &amp;&amp; current &lt; array[preIndex]) {
    		array[preIndex+1] = array[preIndex];
    		preIndex--;
		}
    	//由于确认最终位置后还执行了preIndex--，所以插入的位置是preIndex+1
    	array[preIndex+1] = current;
	}
    return array;
</code></pre>
<h3 id="四、希尔排序（Shell-Sort）"><a class="header-anchor" href="#四、希尔排序（Shell-Sort）">¶</a>四、希尔排序（Shell Sort）</h3>
<p><strong>希尔排序</strong> 是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为 <strong>缩小增量排序</strong> ，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br>
        希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h5 id="1-算法描述-v4"><a class="header-anchor" href="#1-算法描述-v4">¶</a>1.算法描述</h5>
<blockquote>
<p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br>
先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>步骤1：选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>步骤2：按增量序列个数k，对序列进行k 趟排序；</li>
<li>步骤3：每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
</blockquote>
<h5 id="2-过程演示"><a class="header-anchor" href="#2-过程演示">¶</a>2.过程演示</h5>
<p><img src="https://tomush-blog.oss-cn-shenzhen.aliyuncs.com/tomush-blog/imgs/3.jfif" alt="希尔排序演示"></p>
<h5 id="3-代码实现"><a class="header-anchor" href="#3-代码实现">¶</a>3.代码实现</h5>
<pre><code>/**
 * 希尔排序
 */
public static int[] ShellSort(int[] array) {
    int len = array.length;
    int temp, gap = len / 2;
    while (gap &gt; 0) {   //直到增量缩小到1
        for (int i = gap; i &lt; len; i++) {   //第一个增量区内的元素不用比较，从增量后开始
            temp = array[i];	//存储待排序的元素
            int preIndex = i - gap;	//从待排序的元素往回跟前面的增量元素比较
            //当有序区的元素大于该元素，说明还没找到合适的位置
            while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) {
            	//由于上一次循环最后减去了一个gap，所以要加回来，才是上一次比较的元素
                array[preIndex + gap] = array[preIndex];
                preIndex -= gap;
            }
            array[preIndex + gap] = temp;
        }
        gap /= 2;	//结束该次增量的排序，准备开始下一次排序
    }
    return array;
}
</code></pre>
<h3 id="五、归并排序（Merge-Sort）"><a class="header-anchor" href="#五、归并排序（Merge-Sort）">¶</a>五、归并排序（Merge Sort）</h3>
<p><strong>归并排序</strong> 是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。<br>
        和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
<h5 id="1-算法描述-v5"><a class="header-anchor" href="#1-算法描述-v5">¶</a>1.算法描述</h5>
<blockquote>
<ul>
<li>步骤1：把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>步骤2：对这两个子序列分别采用归并排序；</li>
<li>步骤3：将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
</blockquote>
<h5 id="2-代码实现-v4"><a class="header-anchor" href="#2-代码实现-v4">¶</a>2.代码实现</h5>
<pre><code>	/**
 * 归并排序
 *
 * @param array
 * @return
 */
public static int[] MergeSort(int[] array) {
    if (array.length &lt; 2) return array; //1是递归边界，直接返回
    int mid = array.length / 2;
    //把原数组array从下标0到上标mid的元素重新开辟成一个新数组，包括下标，不包括上标
    int[] left = Arrays.copyOfRange(array, 0, mid);
    int[] right = Arrays.copyOfRange(array, mid, array.length);
    return merge(MergeSort(left), MergeSort(right)); //左右递归，分治排序
}
/**
 * 归并排序——将两段排序好的数组结合成一个排序数组
 *
 * @param left
 * @param right
 * @return
 */
public static int[] merge(int[] left, int[] right) {
    int[] result = new int[left.length + right.length];
    for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) {
    	//如果i &gt;= left.length或者j &gt;= right.length，说明某一边已排序完毕，
    	//剩下的另一边元素本来就是有序的，只要按顺序插入就行
        if (i &gt;= left.length)   
            result[index] = right[j++];
        else if (j &gt;= right.length)
            result[index] = left[i++];
        //如果进到这个else,说明两边还没排序完，这时比较左边的元素是否大于右边
        else if (left[i] &gt; right[j])
            result[index] = right[j++];
        else	//两边没排序完，左边小于右边，直接把左边元素插入数组
            result[index] = left[i++];
    }
    return result;
}
</code></pre>
<h3 id="六、快速排序（Quick-Sort）"><a class="header-anchor" href="#六、快速排序（Quick-Sort）">¶</a>六、快速排序（Quick Sort）</h3>
<p><strong>快速排序</strong> 的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h5 id="1-算法描述-v6"><a class="header-anchor" href="#1-算法描述-v6">¶</a>1.算法描述</h5>
<blockquote>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>步骤1：从数列中挑出一个元素（通常为数组第一个），称为 “基准”（pivot ）；</li>
<li>步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
</blockquote>
<h5 id="2-代码实现-v5"><a class="header-anchor" href="#2-代码实现-v5">¶</a>2.代码实现</h5>
<pre><code>public static int[] quickSort(int[] arr, int left, int right) {
	if (left &lt; right) { //如果元素个数不止一个，进行排序
		//获取中轴元素所处的位置
		int mid = partition(arr, left, right);
		//进行分割
		quickSort(arr, left, mid - 1);
		quickSort(arr, mid + 1, right);
	}
	return arr;
}

private static int partition(int[] arr, int left, int right) {
	//思路：选第一个数为基准，从左起第二个元素开始找第一个大于基准的元素，
	//从最后一个元素开始往回找第一个小于基准的元素，交换左边和右边的位置
	//直到右边元素下标小于左边元素，此时交换第一个和右边j的元素，返回J即为中间的数
	//选取中轴元素
	int pivot = arr[left];
	int i = left + 1;
	int j = right;
	while (true) {
		// 向右找到第一个大于 pivot 的元素位置
		while (i &lt;= j &amp;&amp; arr[i] &lt;= pivot)
			i++;
		// 向左找到第一个小于 pivot 的元素位置
		while (i &lt;= j &amp;&amp; arr[j] &gt;= pivot)
			j--;
		if (i &gt;= j) break;
		//交换两个元素的位置，使得左边的元素不大于pivot,右边的不小于pivot
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}
	arr[left] = arr[j];
	// 使中轴元素处于有序的位置
	arr[j] = pivot;
	return j;
}
</code></pre>
<h3 id="七、堆排序（Heap-Sort）"><a class="header-anchor" href="#七、堆排序（Heap-Sort）">¶</a>七、堆排序（Heap Sort）</h3>
<p>堆的特点就是堆顶的元素是一个 <strong>最值</strong> ，大顶堆的堆顶是最大值，小顶堆则是最小值。<br>
堆排序就是把堆顶的元素与最后一个元素交换，交换之后破坏了堆的特性，我们再把堆中剩余的元素再次构成一个大顶堆，然后再把堆顶元素与最后第二个元素交换….如此往复下去，等到剩余的元素只有一个的时候，此时的数组就是有序的了。</p>
<h5 id="1-算法描述-v7"><a class="header-anchor" href="#1-算法描述-v7">¶</a>1.算法描述</h5>
<blockquote>
<ul>
<li>步骤1：将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>步骤2：将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>步骤3：由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
</blockquote>
<h5 id="2-代码实现-v6"><a class="header-anchor" href="#2-代码实现-v6">¶</a>2.代码实现</h5>
<pre><code>// 堆排序
public static int[] headSort(int[] arr) {
	int n = arr.length;
	//构建大顶堆
	//堆(完全二叉树)的最后一个非叶子节点为n/2-1
	//如果节点序号为i，在它的左子节点序号为2i+1，右子节点序号为2i+2
	for (int i = (n - 2) / 2; i &gt;= 0; i--) {
		downAdjust(arr, i, n - 1);
	}
	//进行堆排序
	for (int i = n - 1; i &gt;= 1; i--) {
		// 把堆顶元素与最后一个元素交换
		int temp = arr[i];
		arr[i] = arr[0];
		arr[0] = temp;
		// 把打乱的堆进行调整，恢复堆的特性
		downAdjust(arr, 0, i - 1);
	}
	return arr;
}

//下沉操作
public static void downAdjust(int[] arr, int parent, int n) {
	//临时保存要下沉的元素
	int temp = arr[parent];
	//定位左孩子节点的位置
	int child = 2 * parent + 1;
	//开始下沉
	while (child &lt;= n) {
		// 如果右孩子节点比左孩子大，则定位到右孩子
		if (child + 1 &lt;= n &amp;&amp; arr[child] &lt; arr[child + 1]) child++;
		// 如果孩子节点小于或等于父节点，则下沉结束
		if (arr[child] &lt;= temp) break;
		// 父节点进行下沉
		arr[parent] = arr[child];
		parent = child;
		child = 2 * parent + 1;
	}
	arr[parent] = temp;
}
</code></pre>
<h3 id="八、计数排序（Counting-Sort）"><a class="header-anchor" href="#八、计数排序（Counting-Sort）">¶</a>八、计数排序（Counting Sort）</h3>
<p><strong>计数排序</strong> 的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数，<strong>计数排序是一种适合于最大值和最小值的差值不是不是很大的排序</strong>。<br>
计数排序(Counting sort) 是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
<h5 id="1-算法描述-v8"><a class="header-anchor" href="#1-算法描述-v8">¶</a>1.算法描述</h5>
<blockquote>
<p>基本思想：就是把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，例如 temp[i] = m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。</p>
<ul>
<li>步骤1：找出待排序的数组中最大和最小的元素；</li>
<li>步骤2：统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>步骤3：对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>步骤4：反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
</blockquote>
<h5 id="2-代码实现-v7"><a class="header-anchor" href="#2-代码实现-v7">¶</a>2.代码实现</h5>
<pre><code>public static int[] countSort(int[] arr) {
	if (arr == null || arr.length &lt; 2) return arr;

	int n = arr.length;
	int max = arr[0];
	// 寻找数组的最大值
	for (int i = 1; i &lt; n; i++) {
		if (max &lt; arr[i]) max = arr[i];
	}
	//创建大小为max的临时数组
	int[] temp = new int[max + 1];
	//统计元素i出现的次数
	for (int i = 0; i &lt; n; i++) {
		temp[arr[i]]++;
	}
	int k = 0;
	//把临时数组统计好的数据汇总到原数组
	for (int i = 0; i &lt;= max; i++) {
		for (int j = temp[i]; j &gt; 0; j--) {
			arr[k++] = i;
		}
	}
	return arr;
}
</code></pre>
<h5 id="3-优化"><a class="header-anchor" href="#3-优化">¶</a>3.优化</h5>
<p>        上面的代码中，我们是根据 max 的大小来创建对应大小的数组，假如原数组只有10个元素，并且最小值为 min = 10000，最大值为 max = 10005，那我们创建 10005 + 1 大小的数组太浪费了，最大值与最小值的差值为 5，所以我们创建大小为6的临时数组就可以了。<br>
也就是说，我们创建的临时数组大小 (max - min + 1)就可以了，然后在把 min作为偏移量。优化之后的代码如下所示：<br>
public static int[] sort(int[] arr) {<br>
if (arr == null || arr.length &lt; 2) return arr;</p>
<pre><code>	int n = arr.length;
	int min = arr[0];
	int max = arr[0];
	// 寻找数组的最大值与最小值
	for (int i = 1; i &lt; n; i++) {
		if (max &lt; arr[i]) max = arr[i];
		if (min &gt; arr[i]) min = arr[i];
	}
	int d = max - min + 1;
	//创建大小为max的临时数组
	int[] temp = new int[d];
	//统计元素i出现的次数
	for (int i = 0; i &lt; n; i++) {
		temp[arr[i] - min]++;
	}
	int k = 0;
	//把临时数组统计好的数据汇总到原数组
	for (int i = 0; i &lt; d; i++) {
		for (int j = temp[i]; j &gt; 0; j--) {
			arr[k++] = i + min;
		}
	}
	return arr;
} 
</code></pre>
<h3 id="九、桶排序（Bucket-Sort）"><a class="header-anchor" href="#九、桶排序（Bucket-Sort）">¶</a>九、桶排序（Bucket Sort）</h3>
<p><strong>桶排序</strong> 是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>
桶排序 (Bucket sort)的工作的原理：<br>
假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序),然后再进行合并汇总。</p>
<h5 id="1-算法描述-v9"><a class="header-anchor" href="#1-算法描述-v9">¶</a>1.算法描述</h5>
<blockquote>
<ul>
<li>步骤1：人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li>
<li>步骤2：遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>步骤3：对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li>
<li>步骤4：从不是空的桶里把排好序的数据拼接起来。<br>
注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</li>
</ul>
</blockquote>
<h5 id="2-代码实现-v8"><a class="header-anchor" href="#2-代码实现-v8">¶</a>2.代码实现</h5>
<pre><code>public static int[] BucketSort(int[] arr) {
	if (arr == null || arr.length &lt; 2) return arr;

	int n = arr.length;
	int max = arr[0];
	int min = arr[0];
	// 寻找数组的最大值与最小值
	for (int i = 1; i &lt; n; i++) {
		if (min &gt; arr[i]) min = arr[i];
		if (max &lt; arr[i]) max = arr[i];
	}
	//和优化版本的计数排序一样，弄一个大小为 min 的偏移值
	int d = max - min;
	//创建 d / 5 + 1 个桶，第 i 桶存放  5*i ~ 5*i+5-1范围的数
	int bucketNum = d / 5 + 1;
	ArrayList&lt;LinkedList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;&gt;(bucketNum);
	//初始化桶
	for (int i = 0; i &lt; bucketNum; i++) {
		bucketList.add(new LinkedList&lt;Integer&gt;());
	}
	//遍历原数组，将每个元素放入桶中
	for (int i = 0; i &lt; n; i++) {
		bucketList.get((arr[i] - min) / d).add(arr[i] - min);
	}
	//对桶内的元素进行排序，我这里采用系统自带的排序工具
	for (int i = 0; i &lt; bucketNum; i++) {
		Collections.sort(bucketList.get(i));
	}
	//把每个桶排序好的数据进行合并汇总放回原数组
	int k = 0;
	for (int i = 0; i &lt; bucketNum; i++) {
		for (Integer t : bucketList.get(i)) {
			arr[k++] = t + min;
		}
	}
	return arr;
}   
</code></pre>
<h3 id="十、基数排序（Radix-Sort）"><a class="header-anchor" href="#十、基数排序（Radix-Sort）">¶</a>十、基数排序（Radix Sort）</h3>
<p>基数排序的排序思路是这样的：先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小……<br>
排到最后，就是一组有序的元素了。不过，他在以某位数进行排序的时候，是用“桶”来排序的。<br>
由于某位数（个位/十位….，不是一整个数）的大小范围为0-9，所以我们需要10个桶，然后把具有相同数值的数放进同一个桶里，之后再把桶里的数按照0号桶到9号桶的顺序取出来，这样一趟下来，按照某位数的排序就完成了。</p>
<h5 id="2-代码实现-v9"><a class="header-anchor" href="#2-代码实现-v9">¶</a>2.代码实现</h5>
<pre><code>public static int[] radioSort(int[] arr) {
	if (arr == null || arr.length &lt; 2) return arr;

	int n = arr.length;
	int max = arr[0];
	// 找出最大值
	for (int i = 1; i &lt; n; i++) {
		if (max &lt; arr[i]) max = arr[i];
	}
	// 计算最大值是几位数
	int num = 1;
	while (max / 10 &gt; 0) {
		num++;
		max = max / 10;
	}
	// 创建10个桶
	ArrayList&lt;LinkedList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;&gt;(10);
	//初始化桶
	for (int i = 0; i &lt; 10; i++) {
		bucketList.add(new LinkedList&lt;Integer&gt;());
	}
	// 进行每一趟的排序，从个位数开始排
	for (int i = 1; i &lt;= num; i++) {
		for (int j = 0; j &lt; n; j++) {
			// 获取每个数最后第 i 位是数组
			int radio = (arr[j] / (int) Math.pow(10, i - 1)) % 10;
			//放进对应的桶里
			bucketList.get(radio).add(arr[j]);
		}
		//合并放回原数组
		int k = 0;
		for (int j = 0; j &lt; 10; j++) {
			for (Integer t : bucketList.get(j)) {
				arr[k++] = t;
			}
			//取出来合并了之后把桶清光数据
			bucketList.get(j).clear();
		}
	}
	return arr;
}
</code></pre>
<h3 id="参考博客"><a class="header-anchor" href="#参考博客">¶</a>参考博客</h3>
<p>本博客仅为个人学习记录，其中算法来源基于两遍个人觉得写得比较好的博客，本人仅是一个无情的博客搬运工，并对代码稍有改动，现附上参考来源：<br>
<a href="https://blog.csdn.net/weixin_41190227/article/details/86600821" target="_blank" rel="noopener">超详细十大经典排序算法总结</a><br>
<a href="https://www.cnblogs.com/itsharehome/p/11058010.html" target="_blank" rel="noopener">十大经典排序算法</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/21/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="next" title="快速幂算法学习记录">
                <i class="fa fa-chevron-left"></i> 快速幂算法学习记录
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Hong YueTang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-术语说明"><span class="nav-number">1.0.1.</span> <span class="nav-text">1.术语说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-算法总结"><span class="nav-number">1.0.2.</span> <span class="nav-text">2.算法总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-算法分类"><span class="nav-number">1.0.3.</span> <span class="nav-text">3.算法分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-比较和非比较的区别"><span class="nav-number">1.0.4.</span> <span class="nav-text">4.比较和非比较的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一、冒泡排序（Bubble-Sort）"><span class="nav-number">2.</span> <span class="nav-text">一、冒泡排序（Bubble Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-算法描述"><span class="nav-number">2.0.1.</span> <span class="nav-text">1.算法描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-代码实现"><span class="nav-number">2.0.2.</span> <span class="nav-text">2.代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、选择排序（Selection-Sort）"><span class="nav-number">3.</span> <span class="nav-text">二、选择排序（Selection Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-算法描述-v2"><span class="nav-number">3.0.1.</span> <span class="nav-text">1.算法描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-代码实现-v2"><span class="nav-number">3.0.2.</span> <span class="nav-text">2.代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、插入排序（Insertion-Sort）"><span class="nav-number">4.</span> <span class="nav-text">三、插入排序（Insertion Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-算法描述-v3"><span class="nav-number">4.0.1.</span> <span class="nav-text">1.算法描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-代码实现-v3"><span class="nav-number">4.0.2.</span> <span class="nav-text">2.代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、希尔排序（Shell-Sort）"><span class="nav-number">5.</span> <span class="nav-text">四、希尔排序（Shell Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-算法描述-v4"><span class="nav-number">5.0.1.</span> <span class="nav-text">1.算法描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-过程演示"><span class="nav-number">5.0.2.</span> <span class="nav-text">2.过程演示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-代码实现"><span class="nav-number">5.0.3.</span> <span class="nav-text">3.代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、归并排序（Merge-Sort）"><span class="nav-number">6.</span> <span class="nav-text">五、归并排序（Merge Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-算法描述-v5"><span class="nav-number">6.0.1.</span> <span class="nav-text">1.算法描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-代码实现-v4"><span class="nav-number">6.0.2.</span> <span class="nav-text">2.代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、快速排序（Quick-Sort）"><span class="nav-number">7.</span> <span class="nav-text">六、快速排序（Quick Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-算法描述-v6"><span class="nav-number">7.0.1.</span> <span class="nav-text">1.算法描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-代码实现-v5"><span class="nav-number">7.0.2.</span> <span class="nav-text">2.代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七、堆排序（Heap-Sort）"><span class="nav-number">8.</span> <span class="nav-text">七、堆排序（Heap Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-算法描述-v7"><span class="nav-number">8.0.1.</span> <span class="nav-text">1.算法描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-代码实现-v6"><span class="nav-number">8.0.2.</span> <span class="nav-text">2.代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八、计数排序（Counting-Sort）"><span class="nav-number">9.</span> <span class="nav-text">八、计数排序（Counting Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-算法描述-v8"><span class="nav-number">9.0.1.</span> <span class="nav-text">1.算法描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-代码实现-v7"><span class="nav-number">9.0.2.</span> <span class="nav-text">2.代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-优化"><span class="nav-number">9.0.3.</span> <span class="nav-text">3.优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九、桶排序（Bucket-Sort）"><span class="nav-number">10.</span> <span class="nav-text">九、桶排序（Bucket Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-算法描述-v9"><span class="nav-number">10.0.1.</span> <span class="nav-text">1.算法描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-代码实现-v8"><span class="nav-number">10.0.2.</span> <span class="nav-text">2.代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十、基数排序（Radix-Sort）"><span class="nav-number">11.</span> <span class="nav-text">十、基数排序（Radix Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-代码实现-v9"><span class="nav-number">11.0.1.</span> <span class="nav-text">2.代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考博客"><span class="nav-number">12.</span> <span class="nav-text">参考博客</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hong YueTang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
