<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hong YueTang&#96;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hong YueTang&#96;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hong YueTang">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hong YueTang`s Blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hong YueTang`s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/05/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hong YueTang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hong YueTang`s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/05/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url">十大排序算法学习记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-05T19:12:48+08:00">
                2020-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>        最近在重学算法，说到算法肯定绕不开排序算法，因此特地写了这篇博客总结自己学习十大排序算法的过程，也方便以后自己重温时不要再反复百度吧。</p>
<h3 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h3>
<h5 id="1-术语说明"><a class="header-anchor" href="#1-术语说明">¶</a>1.术语说明</h5>
<blockquote>
<ul>
<li>稳定 ：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li>
<li>不稳定 ：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li>
<li>内排序 ：所有排序操作都在内存中完成；</li>
<li>外排序 ：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li>原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。</li>
<li>非原地排序：需要利用额外的数组来辅助排序。</li>
<li>时间复杂度 ： 一个算法执行所耗费的时间。</li>
<li>空间复杂度 ：运行完一个程序所需内存的大小。</li>
</ul>
</blockquote>
<h5 id="2-算法总结"><a class="header-anchor" href="#2-算法总结">¶</a>2.算法总结</h5>
<p><img src="https://tomush-blog.oss-cn-shenzhen.aliyuncs.com/tomush-blog/imgs/1.jfif" alt="算法总结"></p>
<ul>
<li>名词解释说明</li>
</ul>
<blockquote>
<p>n: 数据规模<br>
k: “桶”的个数<br>
In-place: 占用常数内存，不占用额外内存<br>
Out-place: 占用额外内存</p>
</blockquote>
<h5 id="3-算法分类"><a class="header-anchor" href="#3-算法分类">¶</a>3.算法分类</h5>
<p><img src="https://tomush-blog.oss-cn-shenzhen.aliyuncs.com/tomush-blog/imgs/2.jfif" alt="算法分类"></p>
<h5 id="4-比较和非比较的区别"><a class="header-anchor" href="#4-比较和非比较的区别">¶</a>4.比较和非比较的区别</h5>
<blockquote>
<p>        常见的 <strong>快速排序</strong>、<strong>归并排序</strong>、<strong>堆排序</strong>、<strong>冒泡排序</strong> 等属于 <strong>比较排序</strong>。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置 。<br>
        在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。<br>
        比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。<br>
        <strong>计数排序</strong>、<strong>基数排序</strong>、<strong>桶排序</strong> 则属于 <strong>非比较排序</strong> 。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置 。<br>
        非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。<br>
         非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p>
</blockquote>
<h3 id="一、冒泡排序（Bubble-Sort）"><a class="header-anchor" href="#一、冒泡排序（Bubble-Sort）">¶</a>一、冒泡排序（Bubble Sort）</h3>
<p><strong>冒泡排序</strong> 是一种简单的排序算法。它重复地遍历要排序的数列，从第一位开始比较相邻的两个元素，如果它们的顺序错误就把它们交换过来，直到待排序的元素位于数列最右端，然后重复第二遍比较，直到排序好的元素前一位。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h5 id="1-算法描述"><a class="header-anchor" href="#1-算法描述">¶</a>1.算法描述</h5>
<blockquote>
<ul>
<li>步骤1：比较相邻的元素，如果第一个比第二个元素大，就交换他们的位置；</li>
<li>步骤2：对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>步骤3: 针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>步骤4: 重复步骤1~3，直到排序完成。</li>
</ul>
</blockquote>
<h5 id="2-代码实现"><a class="header-anchor" href="#2-代码实现">¶</a>2.代码实现</h5>
<pre><code>/**
 * 冒泡排序
 */
public static int[] bubbleSort(int[] array) {
    if (array.length == 0)
        return array;
 	//i=array.length-2时只剩下2两个元素未排序，走完这趟循环后数组已排序完毕
    for (int i = 0; i &lt; array.length-1; i++)
        for (int j = 0; j &lt; array.length - 1 - i; j++)
            if (array[j + 1] &lt; array[j]) {
                int temp = array[j + 1];
                array[j + 1] = array[j];
                array[j] = temp;
            }
    return array;
}
</code></pre>
<h3 id="二、选择排序（Selection-Sort）"><a class="header-anchor" href="#二、选择排序（Selection-Sort）">¶</a>二、选择排序（Selection Sort）</h3>
<p><strong>选择排序</strong> 是表现最稳定的排序算法之一 ，<strong>因为无论什么数据进去都是O(n2)的时间复杂度</strong> ，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。<br>
        <strong>选择排序(Selection-sort)</strong> 是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h5 id="1-算法描述-v2"><a class="header-anchor" href="#1-算法描述-v2">¶</a>1.算法描述</h5>
<blockquote>
<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li>步骤1：初始状态：无序区为R[1…n]，有序区为空；</li>
<li>步骤2：第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>步骤3：n-1趟结束，数组有序化了。</li>
</ul>
</blockquote>
<h5 id="2-代码实现-v2"><a class="header-anchor" href="#2-代码实现-v2">¶</a>2.代码实现</h5>
<pre><code> /**
 * 选择排序
 * @param array
 * @return
 */
public static int[] selectionSort(int[] array) {
    if (array.length == 0)
        return array;
    for (int i = 0; i &lt; array.length-1; i++) {
        int minIndex = i;
        for (int j = i+1; j &lt; array.length; j++) {
            if (array[j] &lt; array[minIndex]) //找到最小的数
                minIndex = j; //将最小数的索引保存
        }
        int temp = array[minIndex];
        array[minIndex] = array[i];
        array[i] = temp;
    }
    return array;
}
</code></pre>
<h3 id="三、插入排序（Insertion-Sort）"><a class="header-anchor" href="#三、插入排序（Insertion-Sort）">¶</a>三、插入排序（Insertion Sort）</h3>
<p><strong>插入排序（Insertion-Sort）</strong> 的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h5 id="1-算法描述-v3"><a class="header-anchor" href="#1-算法描述-v3">¶</a>1.算法描述</h5>
<blockquote>
<p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li>步骤1: 从第一个元素开始，该元素可以认为已经被排序；</li>
<li>步骤2: 取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>步骤3: 如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>步骤4: 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>步骤5: 将新元素插入到该位置后；</li>
<li>步骤6: 重复步骤2~5。</li>
</ul>
</blockquote>
<h5 id="2-代码实现-v3"><a class="header-anchor" href="#2-代码实现-v3">¶</a>2.代码实现</h5>
<pre><code>  public static int[] insertionSort(int[] array) {
    if (array.length == 0)
        return array;
    int current,preIndex;
    //第一个元素默认已排序，所以从下标为1开始排序
    for (int i = 1; i &lt; array.length; i++) {
    	current = array[i];  //获取当前要排序的元素
    	preIndex = i-1;	 	 //进入有序区
    	while (preIndex &gt;= 0 &amp;&amp; current &lt; array[preIndex]) {
    		array[preIndex+1] = array[preIndex];
    		preIndex--;
		}
    	//由于确认最终位置后还执行了preIndex--，所以插入的位置是preIndex+1
    	array[preIndex+1] = current;
	}
    return array;
</code></pre>
<h3 id="四、希尔排序（Shell-Sort）"><a class="header-anchor" href="#四、希尔排序（Shell-Sort）">¶</a>四、希尔排序（Shell Sort）</h3>
<p><strong>希尔排序</strong> 是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为 <strong>缩小增量排序</strong> ，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br>
        希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h5 id="1-算法描述-v4"><a class="header-anchor" href="#1-算法描述-v4">¶</a>1.算法描述</h5>
<blockquote>
<p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br>
先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>步骤1：选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>步骤2：按增量序列个数k，对序列进行k 趟排序；</li>
<li>步骤3：每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
</blockquote>
<h5 id="2-过程演示"><a class="header-anchor" href="#2-过程演示">¶</a>2.过程演示</h5>
<p><img src="https://tomush-blog.oss-cn-shenzhen.aliyuncs.com/tomush-blog/imgs/3.jfif" alt="希尔排序演示"></p>
<h5 id="3-代码实现"><a class="header-anchor" href="#3-代码实现">¶</a>3.代码实现</h5>
<pre><code>/**
 * 希尔排序
 */
public static int[] ShellSort(int[] array) {
    int len = array.length;
    int temp, gap = len / 2;
    while (gap &gt; 0) {   //直到增量缩小到1
        for (int i = gap; i &lt; len; i++) {   //第一个增量区内的元素不用比较，从增量后开始
            temp = array[i];	//存储待排序的元素
            int preIndex = i - gap;	//从待排序的元素往回跟前面的增量元素比较
            //当有序区的元素大于该元素，说明还没找到合适的位置
            while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) {
            	//由于上一次循环最后减去了一个gap，所以要加回来，才是上一次比较的元素
                array[preIndex + gap] = array[preIndex];
                preIndex -= gap;
            }
            array[preIndex + gap] = temp;
        }
        gap /= 2;	//结束该次增量的排序，准备开始下一次排序
    }
    return array;
}
</code></pre>
<h3 id="五、归并排序（Merge-Sort）"><a class="header-anchor" href="#五、归并排序（Merge-Sort）">¶</a>五、归并排序（Merge Sort）</h3>
<p><strong>归并排序</strong> 是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。<br>
        和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
<h5 id="1-算法描述-v5"><a class="header-anchor" href="#1-算法描述-v5">¶</a>1.算法描述</h5>
<blockquote>
<ul>
<li>步骤1：把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>步骤2：对这两个子序列分别采用归并排序；</li>
<li>步骤3：将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
</blockquote>
<h5 id="2-代码实现-v4"><a class="header-anchor" href="#2-代码实现-v4">¶</a>2.代码实现</h5>
<pre><code>	/**
 * 归并排序
 *
 * @param array
 * @return
 */
public static int[] MergeSort(int[] array) {
    if (array.length &lt; 2) return array; //1是递归边界，直接返回
    int mid = array.length / 2;
    //把原数组array从下标0到上标mid的元素重新开辟成一个新数组，包括下标，不包括上标
    int[] left = Arrays.copyOfRange(array, 0, mid);
    int[] right = Arrays.copyOfRange(array, mid, array.length);
    return merge(MergeSort(left), MergeSort(right)); //左右递归，分治排序
}
/**
 * 归并排序——将两段排序好的数组结合成一个排序数组
 *
 * @param left
 * @param right
 * @return
 */
public static int[] merge(int[] left, int[] right) {
    int[] result = new int[left.length + right.length];
    for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) {
    	//如果i &gt;= left.length或者j &gt;= right.length，说明某一边已排序完毕，
    	//剩下的另一边元素本来就是有序的，只要按顺序插入就行
        if (i &gt;= left.length)   
            result[index] = right[j++];
        else if (j &gt;= right.length)
            result[index] = left[i++];
        //如果进到这个else,说明两边还没排序完，这时比较左边的元素是否大于右边
        else if (left[i] &gt; right[j])
            result[index] = right[j++];
        else	//两边没排序完，左边小于右边，直接把左边元素插入数组
            result[index] = left[i++];
    }
    return result;
}
</code></pre>
<h3 id="六、快速排序（Quick-Sort）"><a class="header-anchor" href="#六、快速排序（Quick-Sort）">¶</a>六、快速排序（Quick Sort）</h3>
<p><strong>快速排序</strong> 的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h5 id="1-算法描述-v6"><a class="header-anchor" href="#1-算法描述-v6">¶</a>1.算法描述</h5>
<blockquote>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>步骤1：从数列中挑出一个元素（通常为数组第一个），称为 “基准”（pivot ）；</li>
<li>步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
</blockquote>
<h5 id="2-代码实现-v5"><a class="header-anchor" href="#2-代码实现-v5">¶</a>2.代码实现</h5>
<pre><code>public static int[] quickSort(int[] arr, int left, int right) {
	if (left &lt; right) { //如果元素个数不止一个，进行排序
		//获取中轴元素所处的位置
		int mid = partition(arr, left, right);
		//进行分割
		quickSort(arr, left, mid - 1);
		quickSort(arr, mid + 1, right);
	}
	return arr;
}

private static int partition(int[] arr, int left, int right) {
	//思路：选第一个数为基准，从左起第二个元素开始找第一个大于基准的元素，
	//从最后一个元素开始往回找第一个小于基准的元素，交换左边和右边的位置
	//直到右边元素下标小于左边元素，此时交换第一个和右边j的元素，返回J即为中间的数
	//选取中轴元素
	int pivot = arr[left];
	int i = left + 1;
	int j = right;
	while (true) {
		// 向右找到第一个大于 pivot 的元素位置
		while (i &lt;= j &amp;&amp; arr[i] &lt;= pivot)
			i++;
		// 向左找到第一个小于 pivot 的元素位置
		while (i &lt;= j &amp;&amp; arr[j] &gt;= pivot)
			j--;
		if (i &gt;= j) break;
		//交换两个元素的位置，使得左边的元素不大于pivot,右边的不小于pivot
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}
	arr[left] = arr[j];
	// 使中轴元素处于有序的位置
	arr[j] = pivot;
	return j;
}
</code></pre>
<h3 id="七、堆排序（Heap-Sort）"><a class="header-anchor" href="#七、堆排序（Heap-Sort）">¶</a>七、堆排序（Heap Sort）</h3>
<p>堆的特点就是堆顶的元素是一个 <strong>最值</strong> ，大顶堆的堆顶是最大值，小顶堆则是最小值。<br>
堆排序就是把堆顶的元素与最后一个元素交换，交换之后破坏了堆的特性，我们再把堆中剩余的元素再次构成一个大顶堆，然后再把堆顶元素与最后第二个元素交换….如此往复下去，等到剩余的元素只有一个的时候，此时的数组就是有序的了。</p>
<h5 id="1-算法描述-v7"><a class="header-anchor" href="#1-算法描述-v7">¶</a>1.算法描述</h5>
<blockquote>
<ul>
<li>步骤1：将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>步骤2：将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>步骤3：由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
</blockquote>
<h5 id="2-代码实现-v6"><a class="header-anchor" href="#2-代码实现-v6">¶</a>2.代码实现</h5>
<pre><code>// 堆排序
public static int[] headSort(int[] arr) {
	int n = arr.length;
	//构建大顶堆
	//堆(完全二叉树)的最后一个非叶子节点为n/2-1
	//如果节点序号为i，在它的左子节点序号为2i+1，右子节点序号为2i+2
	for (int i = (n - 2) / 2; i &gt;= 0; i--) {
		downAdjust(arr, i, n - 1);
	}
	//进行堆排序
	for (int i = n - 1; i &gt;= 1; i--) {
		// 把堆顶元素与最后一个元素交换
		int temp = arr[i];
		arr[i] = arr[0];
		arr[0] = temp;
		// 把打乱的堆进行调整，恢复堆的特性
		downAdjust(arr, 0, i - 1);
	}
	return arr;
}

//下沉操作
public static void downAdjust(int[] arr, int parent, int n) {
	//临时保存要下沉的元素
	int temp = arr[parent];
	//定位左孩子节点的位置
	int child = 2 * parent + 1;
	//开始下沉
	while (child &lt;= n) {
		// 如果右孩子节点比左孩子大，则定位到右孩子
		if (child + 1 &lt;= n &amp;&amp; arr[child] &lt; arr[child + 1]) child++;
		// 如果孩子节点小于或等于父节点，则下沉结束
		if (arr[child] &lt;= temp) break;
		// 父节点进行下沉
		arr[parent] = arr[child];
		parent = child;
		child = 2 * parent + 1;
	}
	arr[parent] = temp;
}
</code></pre>
<h3 id="八、计数排序（Counting-Sort）"><a class="header-anchor" href="#八、计数排序（Counting-Sort）">¶</a>八、计数排序（Counting Sort）</h3>
<p><strong>计数排序</strong> 的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数，<strong>计数排序是一种适合于最大值和最小值的差值不是不是很大的排序</strong>。<br>
计数排序(Counting sort) 是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
<h5 id="1-算法描述-v8"><a class="header-anchor" href="#1-算法描述-v8">¶</a>1.算法描述</h5>
<blockquote>
<p>基本思想：就是把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，例如 temp[i] = m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。</p>
<ul>
<li>步骤1：找出待排序的数组中最大和最小的元素；</li>
<li>步骤2：统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>步骤3：对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>步骤4：反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
</blockquote>
<h5 id="2-代码实现-v7"><a class="header-anchor" href="#2-代码实现-v7">¶</a>2.代码实现</h5>
<pre><code>public static int[] countSort(int[] arr) {
	if (arr == null || arr.length &lt; 2) return arr;

	int n = arr.length;
	int max = arr[0];
	// 寻找数组的最大值
	for (int i = 1; i &lt; n; i++) {
		if (max &lt; arr[i]) max = arr[i];
	}
	//创建大小为max的临时数组
	int[] temp = new int[max + 1];
	//统计元素i出现的次数
	for (int i = 0; i &lt; n; i++) {
		temp[arr[i]]++;
	}
	int k = 0;
	//把临时数组统计好的数据汇总到原数组
	for (int i = 0; i &lt;= max; i++) {
		for (int j = temp[i]; j &gt; 0; j--) {
			arr[k++] = i;
		}
	}
	return arr;
}
</code></pre>
<h5 id="3-优化"><a class="header-anchor" href="#3-优化">¶</a>3.优化</h5>
<p>        上面的代码中，我们是根据 max 的大小来创建对应大小的数组，假如原数组只有10个元素，并且最小值为 min = 10000，最大值为 max = 10005，那我们创建 10005 + 1 大小的数组太浪费了，最大值与最小值的差值为 5，所以我们创建大小为6的临时数组就可以了。<br>
也就是说，我们创建的临时数组大小 (max - min + 1)就可以了，然后在把 min作为偏移量。优化之后的代码如下所示：<br>
public static int[] sort(int[] arr) {<br>
if (arr == null || arr.length &lt; 2) return arr;</p>
<pre><code>	int n = arr.length;
	int min = arr[0];
	int max = arr[0];
	// 寻找数组的最大值与最小值
	for (int i = 1; i &lt; n; i++) {
		if (max &lt; arr[i]) max = arr[i];
		if (min &gt; arr[i]) min = arr[i];
	}
	int d = max - min + 1;
	//创建大小为max的临时数组
	int[] temp = new int[d];
	//统计元素i出现的次数
	for (int i = 0; i &lt; n; i++) {
		temp[arr[i] - min]++;
	}
	int k = 0;
	//把临时数组统计好的数据汇总到原数组
	for (int i = 0; i &lt; d; i++) {
		for (int j = temp[i]; j &gt; 0; j--) {
			arr[k++] = i + min;
		}
	}
	return arr;
} 
</code></pre>
<h3 id="九、桶排序（Bucket-Sort）"><a class="header-anchor" href="#九、桶排序（Bucket-Sort）">¶</a>九、桶排序（Bucket Sort）</h3>
<p><strong>桶排序</strong> 是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>
桶排序 (Bucket sort)的工作的原理：<br>
假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序),然后再进行合并汇总。</p>
<h5 id="1-算法描述-v9"><a class="header-anchor" href="#1-算法描述-v9">¶</a>1.算法描述</h5>
<blockquote>
<ul>
<li>步骤1：人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li>
<li>步骤2：遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>步骤3：对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li>
<li>步骤4：从不是空的桶里把排好序的数据拼接起来。<br>
注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</li>
</ul>
</blockquote>
<h5 id="2-代码实现-v8"><a class="header-anchor" href="#2-代码实现-v8">¶</a>2.代码实现</h5>
<pre><code>public static int[] BucketSort(int[] arr) {
	if (arr == null || arr.length &lt; 2) return arr;

	int n = arr.length;
	int max = arr[0];
	int min = arr[0];
	// 寻找数组的最大值与最小值
	for (int i = 1; i &lt; n; i++) {
		if (min &gt; arr[i]) min = arr[i];
		if (max &lt; arr[i]) max = arr[i];
	}
	//和优化版本的计数排序一样，弄一个大小为 min 的偏移值
	int d = max - min;
	//创建 d / 5 + 1 个桶，第 i 桶存放  5*i ~ 5*i+5-1范围的数
	int bucketNum = d / 5 + 1;
	ArrayList&lt;LinkedList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;&gt;(bucketNum);
	//初始化桶
	for (int i = 0; i &lt; bucketNum; i++) {
		bucketList.add(new LinkedList&lt;Integer&gt;());
	}
	//遍历原数组，将每个元素放入桶中
	for (int i = 0; i &lt; n; i++) {
		bucketList.get((arr[i] - min) / d).add(arr[i] - min);
	}
	//对桶内的元素进行排序，我这里采用系统自带的排序工具
	for (int i = 0; i &lt; bucketNum; i++) {
		Collections.sort(bucketList.get(i));
	}
	//把每个桶排序好的数据进行合并汇总放回原数组
	int k = 0;
	for (int i = 0; i &lt; bucketNum; i++) {
		for (Integer t : bucketList.get(i)) {
			arr[k++] = t + min;
		}
	}
	return arr;
}   
</code></pre>
<h3 id="十、基数排序（Radix-Sort）"><a class="header-anchor" href="#十、基数排序（Radix-Sort）">¶</a>十、基数排序（Radix Sort）</h3>
<p>基数排序的排序思路是这样的：先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小……<br>
排到最后，就是一组有序的元素了。不过，他在以某位数进行排序的时候，是用“桶”来排序的。<br>
由于某位数（个位/十位….，不是一整个数）的大小范围为0-9，所以我们需要10个桶，然后把具有相同数值的数放进同一个桶里，之后再把桶里的数按照0号桶到9号桶的顺序取出来，这样一趟下来，按照某位数的排序就完成了。</p>
<h5 id="2-代码实现-v9"><a class="header-anchor" href="#2-代码实现-v9">¶</a>2.代码实现</h5>
<pre><code>public static int[] radioSort(int[] arr) {
	if (arr == null || arr.length &lt; 2) return arr;

	int n = arr.length;
	int max = arr[0];
	// 找出最大值
	for (int i = 1; i &lt; n; i++) {
		if (max &lt; arr[i]) max = arr[i];
	}
	// 计算最大值是几位数
	int num = 1;
	while (max / 10 &gt; 0) {
		num++;
		max = max / 10;
	}
	// 创建10个桶
	ArrayList&lt;LinkedList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;&gt;(10);
	//初始化桶
	for (int i = 0; i &lt; 10; i++) {
		bucketList.add(new LinkedList&lt;Integer&gt;());
	}
	// 进行每一趟的排序，从个位数开始排
	for (int i = 1; i &lt;= num; i++) {
		for (int j = 0; j &lt; n; j++) {
			// 获取每个数最后第 i 位是数组
			int radio = (arr[j] / (int) Math.pow(10, i - 1)) % 10;
			//放进对应的桶里
			bucketList.get(radio).add(arr[j]);
		}
		//合并放回原数组
		int k = 0;
		for (int j = 0; j &lt; 10; j++) {
			for (Integer t : bucketList.get(j)) {
				arr[k++] = t;
			}
			//取出来合并了之后把桶清光数据
			bucketList.get(j).clear();
		}
	}
	return arr;
}
</code></pre>
<h3 id="参考博客"><a class="header-anchor" href="#参考博客">¶</a>参考博客</h3>
<p>本博客仅为个人学习记录，其中算法来源基于两遍个人觉得写得比较好的博客，本人仅是一个无情的博客搬运工，并对代码稍有改动，现附上参考来源：<br>
<a href="https://blog.csdn.net/weixin_41190227/article/details/86600821" target="_blank" rel="noopener">超详细十大经典排序算法总结</a><br>
<a href="https://www.cnblogs.com/itsharehome/p/11058010.html" target="_blank" rel="noopener">十大经典排序算法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/21/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hong YueTang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hong YueTang`s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/21/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url">快速幂算法学习记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-21T21:10:48+08:00">
                2020-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在牛客网上刷到一道有关快速幂的算法题，题目如下：</p>
<blockquote>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>
保证base和exponent不同时为0</p>
</blockquote>
<p>在解答这道算法题前，需要先了解下快速幂是什么。</p>
<h1>什么是快速幂</h1>
<p>回到题目，要求一个数的n次方，有的同学可能就要问了，这不是一个for循环就搞定的事吗？</p>
<pre><code>public double Power(double base, int exponent) {
	double result = 1;
	for (int i = 1; i &lt;= exponent; i++) {
		result *= base;
	}
	return result;
}
</code></pre>
<p>        事实上，这样确实也能得出结果，只是一个个运算无疑太慢了，指数太大的话比较耗时间，那有没有能压缩时间复杂度的算法呢？答案就是快速幂。</p>
<p>        我们知道，传统的求幂算法之所以时间复杂度比较高，是因为当指数很大时，需要执行的循环次数则会变得很多。那么只要把指数缩小，相应的循环次数也会降低，这就是快速幂的目的。所谓快速幂，就是在求幂的每一步都把指数缩小一半，底数则相应做一次平方运算，通过降低指数的值，把循环次数减少，而结果也不会变。</p>
<p>举个例子，现在要算3的10次方，即：</p>
<blockquote>
<p>$3^{10} = 3\times3\times3\times3\times3\times3\times3\times3\times3\times3$<br>
$3^{10} = (3\times3)\times(3\times3)\times(3\times3)\times(3\times3)\times(3\times3)$<br>
$3^{10} = (3\times3)^5$<br>
$3^{10} = 9^5$<br>
        可以看到，原本要对3进行10次循环操作，现在只要对9循环5次就可以得到相同的结果，我们用了一次底数平方操作，就减少了一半的循环量，这在指数特别大的时候效果是很明显的，比如进行2的10000次方，这时只要循环5000次4的幂就够了。<br>
        接下来再把指数5变为一半，5是个奇数，我们不能简单粗暴地把$5\div2$,因为5的一半2.5是个小数，而对数不能为小数，这里我们可以用另一种形式表示$9^5 $:<br>
$9^5 = ( 9^4 )\times( 9^1 )$<br>
        此时我们抽出底数的一次方，即$9^1 $，剩下的$9^4 $又能进行“缩指数”操作了，继续把指数缩小一半<br>
$9^5 = ( 81^2 )\times( 9^1 )$<br>
再缩小一次<br>
$9^5 = ( 6561^1 )\times( 9^1 )$<br>
此时指数又变成一个奇数1，按上述步骤抽出一个底数的一次方，即$6561^1 $，但此时指数却变成了0，意味着我们无法“缩指数”了。<br>
$9^5 = ( 6561^0 )\times( 9^1 )\times( 6561^1 )=1\times( 9^1 )\times(6561^1 )=( 9^1 )\times( 6561^1 )=9\times6561=59049$<br>
        我们发现，最后的结果是$9\times6561$。而9是怎么产生的呢，可以看到，当指数为奇数5时，底数为9，而6561则是指数为奇数1时的底数。总结规律：最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积。</p>
</blockquote>
<p>接下来，让我们用代码演示一下以上算法思路：</p>
<pre><code>public static double Power(double base, int exponent) {
	//先判断边界
	if (exponent == 0) {
		return 1.0;
	}
	if (base - 0.0 == 0.00001 || base - 0.0 == -0.00001) {
		if (exponent &lt; 0) {
			throw new RuntimeException(&quot;除0异常&quot;);
		}
		else {
			return 0.0;
		}
	}
	int e = exponent &gt; 0 ? exponent : -exponent;
	double res = 1;
	while (e != 0) {
		//判断是否为奇数，把所有奇数项的底数相乘，偶数项不处理
		//无论奇偶项，底数增加一次底数，然后指数除以2，减小一半
		res = e%2 == 1 ? res * base : res;
		base *= base;
		e = e/2;
	}
	//最后判断指数是否大于0
	return exponent &gt; 0 ? res : 1 / res;
}
</code></pre>
<p>        以上代码就是快速幂的实现过程，事实上，我们还能进一步优化，e%2 == 1可以用更快的“位运算”来代替，例如 e&amp;1。如果e为偶数，则其二进制最后一位一定是0；如果e为奇数，则其最后一位一定是1。那么我们只要拿e与1的二进制做“与”运算，得到的就是e二进制的最后一位数字了，是0则为偶数，是1则为奇数。例如5是奇数，则5&amp;1=1；而6是偶数，则6&amp;1=0；因此奇偶数的判断就可以用“位运算”来替换了。<br>
        同样，对于e = e/2来说，也可以用更快的“位运算”进行替代，我们只要把e的二进制表示向右移动1位就能变成原来的一半了。例如:</p>
<blockquote>
<p>6    00000110<br>
3    00000011</p>
</blockquote>
<p>最后我们的代码就变为这样：</p>
<pre><code>public static double Power(double base, int exponent) {
	//快速幂，把所有奇数项的底数相乘，偶数项不处理
	//无论奇偶项，底数增加一次底数，然后指数除以2，减小一半
	//即3^8=(3*3)^4=9^4
	if (exponent == 0) {
		return 1.0;
	}
	if (base - 0.0 == 0.00001 || base - 0.0 == -0.00001 ) {
		if (exponent &lt; 0) {
			throw new RuntimeException(&quot;除0异常&quot;);
		} else {
			return 0.0;
		}
	}
	int e = exponent &gt; 0? exponent : -exponent;
	double result = 1.0;
	while (e != 0) {
		//e&amp;1=0的话为偶数,e&amp;1=1的话为奇数
		result = (e&amp;1) != 0 ? result * base : result;
		base *= base;
		//左移1位就是缩小一半
		e = e &gt;&gt; 1;
	}
	return exponent &gt; 0? result : 1/result;	
}
</code></pre>
<p>        以上就是用快速幂求该算法题的代码，有兴趣的可以比较下普通求幂和下面两种快速幂所需的时间，可以发现用“与运算”的快速幂速度非常快。</p>
<p>        最后，附上该题另一种解法–递归法，有兴趣的同学可以看下，这里就不展开说了：</p>
<pre><code>public static double Power(double base, int exponent) {
	if (exponent == 0) {
		return 1.0;
	}
	if (base - 0.0 == 0.00001 || base - 0.0 == -0.00001) {
		if (exponent &lt; 0) {
			throw new RuntimeException(&quot;除0异常&quot;);
		}
		else {
			return 0.0;
		}
	}
	return exponent &gt; 0 ? getPower(base, exponent) : 1 / getPower(base,
			-exponent);
}

public static double getPower(double base, int e) {
	if (e == 1) {
		return base;
	}
	double halfPower = getPower(base, e &gt;&gt; 1);
	return (e &amp; 1) != 0 ? base * halfPower * halfPower : halfPower
			* halfPower;
}
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/04/MySql%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hong YueTang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hong YueTang`s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/04/MySql%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%E8%AE%B0%E5%BD%95/" itemprop="url">MySql常用语句记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-04T04:45:48+08:00">
                2020-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>本来第一篇博客想分享下Java开发中踩过的坑--for循环中进行元素增删操作的问题。由于初试hexo+github pages，对hexo的主题配置之类的玩上瘾了，导致时间有点晚，因为这次只记录一些常用的mysql语句，大家看看就好，希望能对你们有所帮助。</code></pre><p>1)MySql的内外连接语句</p>
<pre><code>内连接: inner join on    
语句：select * from a_table a inner join b_table b on a.a_id = b.b_id
特点：查找左右两表的交集部分

左连接：left join on
语句：select * from a_table a left join b_table b on a.a_id = b.b_id;
特点：查找左表的记录，右表记录不一定存在，如果没找到符合条件的右表数据则显示null

右连接：right join on
语句：select * from a_table a right join b_table b on a.a_id = b.b_id;
特点：查找右表的记录，左表记录不一定存在，如果没找到符合条件的左表数据则显示null</code></pre><p>2)排序语句</p>
<pre><code>正序 order by /order by asc
倒序 order by desc</code></pre><p>3)分组语句</p>
<pre><code>group by,一般配合聚合函数使用，如计数（COUNT），求和（SUM），求平均数（AVG）</code></pre><p>4)拼接语句</p>
<pre><code>a.concat()函数
语法：concat(str1, str2,...)
用途：将多个字符串连接成一个字符串，如果有任何一个参数为null，则返回值为null。

b.concat_ws()函数
语法：concat_ws(separator, str1, str2, ...)
用途：和concat()一样，将多个字符串连接成一个字符串，但是可以指定分隔符。如果分隔符(separator)为 NULL，则结果为 NULL。函数会忽略任何分隔符参数后的 NULL 值。

c.group_concat()函数
语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator &apos;分隔符&apos;] )
用途：这个函数很好用，可以将group by产生的同一个分组中的值连接起来，返回一个字符串结果。如果使用distinct则会排除重复值；如果希望对结果中的值进行排序，可以使用order by子句；separator是一个字符串值，默认为逗号。</code></pre><p>MySql还有很多好用的函数，后续会陆续在文中补充，天色已晚，改天再战。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Hong YueTang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hong YueTang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
